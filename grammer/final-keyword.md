# final 关键字

`final` 关键字指的是“这是无法改变的”。不想做改变可能出于两种理由：设计或效率。

可能使用到 `final` 的有四种情况：域、参数、方法和类。简单的说，`final` 关键字在声明域、参数、方法和类时，分别表示域不可变、参数不可变、方法不可覆盖和类不可继承。

## final 域

`final` 声明的基本类型是一个*编译时常量*，其值不可改变。在对这个常量进行定义的时候，必须对其进行赋值。

*   对于编译时常量，也就是说可以在编译时执行计算式，这减轻了一些运行时的负担。
	
*   不能因为某数据是 `final` 的就认为在编译时可以知道它的值。比如在运行时使用随机生成的数值来执行初始化。

`final` 声明的引用类型，其引用不可改变，一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象。然而，对象自身是可以被修改的。

*   Java 并未提供使对象恒定不变的途径，但是可以自己编写类以取得使对象恒定不变的效果。

*   对于不可变类的参数对象，对象的内容也不能被修改，实际上是创建了一个新对象。
	
**空白 final**

Java 允许生成“空白 final”，所谓空白 `final` 是指被声明为 `final` 但又未给定初值的域。

无论什么情况，编译器确保空白 `final` 在使用前必须被初始化。这可以在域的定义处、初始化块或每个构造器中对 `final` 域进行赋值。 

空白 `final` 在关键字 `fianl` 的使用上提供了更大的灵活性，为此，一个类中的 `final` 域可以做到根据对象而有所不同，却又保持不变的特性。

## final 参数

`final` 参数意味着不能在该方法中修改基本类型参数的值，或者引用类型参数的引用。这一特性主要用于向匿名内部类传递数据。

方法中声明的匿名内部类只能访问该方法内的 `final` 类型的局部变量，用 `final` 声明的局部变量相当于一个常量，它的生命周期超出方法运行的生命周期。

## final 方法

`final` 方法具有两个作用：

1.  使用 `final` 方法可以把方法锁定，以防任何继承类修改它的含义。换句话说，`final` 方法确保在继承中该方法的行为保持不变，并且不会被覆盖。

2.  `final` 方法不能被覆盖，这样就有效地“关闭”了动态绑定。因此编译器可以针对 `final` 方法生成更有效的代码。然而，大多数情况下，这对程序的整体性能不会有明显的改观。

**final 和 private 关键字**

`private` 方法是隐式 `final` 的。由于无法取用 `private` 方法，所以也就无法覆盖它。

覆盖只有在某方法是基类的接口的一部分时才会出现。即，必须能将一个对象向上转型为它的基本类型并调用相同的方法。`private` 方法并不是基类接口的一部分，它对于导出类是不可见的。如果在导出类中生成了同名的 `public`、`protected` 或包访问权限的方法的话，这时仅仅是生成了一个新方法。

## final 类

声明为 `final` 的类不能被继承。由于 `final` 类禁止继承，所以 `final` 类中的所有方法都是隐式 `final` 的。

注意，`final` 类不能声明为 `abstract`。由关键字 `abstract` 定义的抽象类含有必须由继承自它的子类重载实现的抽象方法，因此无法同时用 `final` 和 `abstract` 来修饰同一个类。同样的道理，`final` 也不能用来修饰接口。