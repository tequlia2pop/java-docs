# 操作符

## 直接常量

一般来说，如果在程序里使用了“直接常量”，编译器可以准确地知道要生成什么样的类型，但有时候却是模棱两可的。如果发生这种情况，必须对编译器加以适当的“指导”，用与直接常量相关的某些字符来额外增加一些信息。

*   使用后缀字符来表示数值的类型

	* 大写（或小写）的 `L` 代表 `long`；

	* 大写（或小写）的 `F` 代表 `float`；

	* 大写（或小写）的 `D` 代表 `double`。

*   使用前缀字符来表示不同进制的数值

	* 十六进制数适用于所有的整数数据类型，以前缀 `0x`（或 `0X`），后面跟随 `0-9` 和小写（或大写）的 `a-f` 来表示。

	* 八进制数由前缀 `0` 以及后续的 `0-7` 的数字来表示。

	* 二进制数在 Java 中没有直接常量表示方法。在 Java 中，可以使用 `Integer` 或 `Long` 类型的静态方法 `toBinaryString()` 将数值转化为二进制形式。注意，如果将比较小的类型传递给 `Integer.toBinaryString()`，则该类型将自动被转换为 `int`。

*   指数记数法

	在 Java 中，`e` 代表“10的幂次”。例如，Java 中的 `1.39e^(-43)f` 表示 1.39×10^(-43)。

	注意，如果编译器能够正确地识别类型，就不必在数值后附加字符：例如：`long n3 = 200;`。

	然而，对于语句 `float f4 = 1e-43f;// 10 to the power`。编译器通常会将指数作为双精度数（`double`）处理，所以假如没有这个尾随的 `f`，就会收到一条出错提示，告诉我们必须使用类型转换将 `double` 转换成 `float`。

## 按位操作符

按位操作符用来操作整数基本数据类型中的单个“比特”（bit），即二进制位。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。

* 按位“与”（`&`）：如果两个输入位都是1，则生成输出位1；否则生成输出位0。
* 按位“或”（`|`）：如果两个输入位中只要有一个是1，则生成输出位1；只有在两个输入位都是0的情况下，生成输出位0。
* 按位“异或”（`^`）：如果两个输入位中仅有一个是1（另一个是0），则生成输出位1。
* 按位“非”（`~`）：也称取反操作符，属于一元操作符。它生成与输入位相反的值——若输入0，则输出1；若输入1，则输出0。

按位操作符可与等号（`=`）联合使用，以便合并运算和赋值。（由于 `~` 是一元操作符，所以不可与 `=` 联合使用）

将布尔类型作为一种单比特值对待，可以对它执行按位“与”、按位“或”和按位“异或”运算，但不能执行按位“非”（大概是为了避免与逻辑 `NOT` 混淆）。对于布尔值，按位操作符具有与逻辑操作符相同的效果，只是他们不会中途短路。此外，针对布尔值进行的按位运算新增了一个“异或”逻辑操作符，它并未包括在“逻辑”操作符的列表中。

## 移位操作符

移位操作符用来操作整数基本数据类型的“位”。

* 左移位操作符（`<<`）：按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）。

* “有符号”右移位操作符（`>>`）：按照操作符右侧指定的位数将操作符左边的操作数向右移动。“有符号”右移位操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1。

* “无符号”右移位操作符（`>>>`）：使用“零扩展”：无论正负，都在高位插入0。

如果对 `byte` 或 `short` 值进行移位处理，那么在移位进行之前，它们会被转换成 `int` 类型，并且得到的结果也是一个 `int` 类型的值。只有数值右端的低5位才有用，这样可以防止我们移位超过 `int` 型值所具有的位数。（因为2的5次方为32，而 int 型值只有32位。）若对一个 `long` 类型的数值进行处理，最后得到的结果也是 `long`。此时只会用到数值右端的低6位，以防止移位超过 `long` 型数值具有的位数。

“移位”可与“等号”（`<<=` 或 `>>=` 或 `>>>=`）组合使用。但在进行“无符号”右移位结合赋值操作时，可能会遇到一个问题：如果对 `byte` 和 `short` 进行移位运算，得到的可能不是正确的结果。它们会先被转换成 `int`，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。

注意，二进制值的最高位表示符号，0为正，1为负。

## 位运算技巧

位运算技巧 | 实现 | 说明
---------- | ---- | ----
从低位到高位，取n的第m位 | `(n >> (m-1)) & 1` | 
从低位到高位，将n的第m位置1 | n &#124; (1 << (m-1)) | 将1左移 m-1 位找到第m位，得到 000...1...000，再将n和这个数做或运算
从低位到高位，将n的第m位置0 | `n & ~(1 << (m-1))` | 将1左移 m-1 位找到第m位，取反后变成 111...0...1111 ，再将n和这个数做与运算

下面是一些对程序效率上没有明显提高的位运算技巧，也是位运算的常识：

位运算技巧 | 实现 | 说明
---------- | ---- | ----
计算 n+1 | `-~n`
计算 n-1 | `~-n`
取相反数 | `~n + 1` 或 `(n ^ -1) + 1` 或 `x = a ^ b ^ x;`
sign 函数，参数为n，当 n>0 时候返回1，n<0 时返回 -1，n=0 时返回0 | `return !!n - (((unsigned)n >> 31) << 1);`

**参考资料**

[位运算之——按位与（&）操作——（快速取模算法）](http://blog.sina.com.cn/s/blog_7b7cad23010163vy.html)

[优秀程序员不得不知道的20个位运算技巧](http://blog.csdn.net/zmazon/article/details/8262185)

