# 反射

## 概述

通过 RTTI 可以在运行时识别对象和类的信息，但是有一个限制：这个类型在编译时必须已知。换句话说，在编译时，编译器必须知道所有要通过 RTTI 来处理的类。

但是，假设你获取了一个指向某个并不在你的程序空间中的对象的引用：事实上，在编译时你的程序根本没法获知这个对象所属的类。例如，你从磁盘文件，或者网络连接中获取了一串字节，并且你被告知这些字节代表了一个类。

在传统的编程环境下不太可能出现这种情况。但当我们置身于更大规模的编程世界中，在许多重要情况下就会发生上面的事情：

*   “基于构件的编程”：在这种编程方式下，将使用某种基于快速应用开发（RAD）的应用构建工具，即集成开发环境（IDE），来构建项目。这是一种可视化编程方法，可以通过将代表不同组件的图标拖曳到表单中来创建程序。然后在编程时通过设置构件的属性值来配置它们。这种设计时的配置，要求构件都是可实例化的，并且要暴露其部分信息，以允许程序员读取和修改构件的属性。此外，处理图形化用户界面（GUI）事件的构件还必须暴露相关方法的信息，以便 IDE 能够帮助程序员覆盖这些处理事件的方法。反射提供了一种机制——用来检查可用的方法，并返回方法名。Java 通过 JavaBeans 提供了基于构件的编程架构。

*   远程方法调用（RMI）：RMI 允许一个 Java 程序将对象分布到多台机器上，它提供了在跨网络的远程平台上创建和运行对象的能力。需要这种分布能力是有许多原因的:

	* 你可能正在执行一项需进行大量计算的任务，为了提高运算速度，想将计算划分到许多小的计算单元，分布到空闲的机器上运行。
	
	* 你可能希望将处理特定类型任务的代码置于特定的机器上，于是这台机器就成了描述这些动作的公共场所，可以很容易地通过改动它就达到影响系统中所有人的效果。（这是一种有趣的开发方式，因为机器的存在仅仅是为了方便软件的改动！）
	
	* 适于执行特殊任务的专用硬件，例如矩阵转置。

反射机制使得能够创建一个在编译时完全未知的对象，并调用此对象的方法。
	
反射机制并没有什么神奇之处。当通过反射与一个未知类型的对象打交道时，JVM 只是简单地检查这个对象，看它属于哪个特定的类（就像 RTTI 那样）。在用它做其他事情之前必须先加载那个类的 `Class` 对象。因此，那个类的 `Class` 对象对于 JVM 来说必须是可获取的：要么在本地机器上，要么可以通过网络取得。RTTI 和反射之间的真正区别只在于，对 RTTI 来说，编译器在编译时打开和检查 `.class` 文件。（换句话说，我们可以用“普通”方式调用对象的所有方法。）而对于反射来说，`.class` 文件在编译时是不可获取的，所以是在运行时打开和检查 `.class` 文件。

对于习惯于静态检查的的安全性的人来说，你可以执行一些只能在运行时进行的检查，并用异常来报告检查结果的行为，这本身就是一种错误的方法。当然，尽力编写能够进行静态检查的代码是值得的，但是一致的错误报告模型的存在使我们能够通过使用反射编写动态代码。当然，尽力编写能够进行静态检查的代码是值得的，只要你确实能够这么做。但是动态代码是将 Java 与其他诸如 C++ 这样的语言区分开的重要工具之一。

## 反射类库

`Class` 类与 `java.lang.reflect` 类库一起对反射的概念进行了支持。该类库包含了 `Field`、`Method` 以及 `Constructor` 类（每个类都实现了 `Member` 接口）。这些类型的对象是由 JVM 在运行时创建的，用以表示未知类型对应的成员。这样，匿名对象的类信息就能在运行时完全确定下来，而在编译时不需要知道任何事情。

*   可以使用 `Class#forName()` 获得指定类的 `Class` 引用。

*   可以使用 `Class` 类的 `getFields()`、`getMethods()` 和 `getConstructors()` 等很便利的方法，以返回表示字段、方法以及构造器的对象的数组。

*   可以使用 `Constructor` 类来创建新的对象。

*   可以使用 `get()` 和 `set()` 读取和修改与 `Field` 对象关联的字段。

*   可以使用 `invoke()` 调用与 `Method` 对象关联的方法。

在 JDK 文档中，通过查找 `Class` 类可了解更多相关资料。

## 反射的应用

反射在 Java 中是用来支持其他特性的，例如对象序列化和 JavaBean。通常你不需要直接使用反射工具，但是它们在你需要创建更加动态的代码时会很有用。

*   使用反射动态地提取某个类的信息。

*   调用某个类的方法或访问其中的域（包括私有方法和域）。使用反射可以执行违反访问权限的操作，这也算是类的一个后门，但是它使得你能够解决某些特定类型的问题；但如果不这样做，这些问题将难以或者不可能解决。

### 类方法提取器

使用反射可以提取一个类的所有方法，甚至那些在基类中定义的方法。
 
在编程时，特别是如果不记得一个类是否有某个方法，或者不知道一个类究竟能做些什么，而又不想通过索引或类的层次结构去查找 JDK 文档，这时这个工具确实能节省很多时间。

### 调用私有方法和访问私有域

使用反射可以调用类的所有方法，甚至 `private` 方法；也可以访问类的所有非 `final` 域，甚至 `private` 域。

`final` 域实际上在遭遇修改时是安全的。运行时系统会在不抛出异常的情况接受任何修改尝试，但是实际上不会发生任何修改。

```java
static void callHiddenMethod(Object a, String methodName) throws Exception {
	Method g = a.getClass().getDeclaredMethod(methodName);
	g.setAccessible(true);
	g.invoke(a);
}

static Object getHiddenField(Object a, String fieldName) throws Exception {
	Field f = a.getClass().getDeclaredField(fieldName);
	f.setAccessible(true);
	return f.get(a);
}
```
